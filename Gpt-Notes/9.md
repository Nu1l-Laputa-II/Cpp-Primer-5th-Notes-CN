# 第9章 顺序容器 - 总结笔记

---

## **1. 顺序容器概述**

### **1.1 容器类型及特性**

|      容器类型       |                     特性                     |
| :------------------: | :------------------------------------------: |
| **`vector`**         | 动态数组，支持 **快速随机访问**，尾部插入快；在中间插入/删除较慢。 |
| **`deque`**          | 双端队列，支持 **快速随机访问**，在 **两端插入/删除** 快。 |
| **`list`**           | 双向链表，只支持顺序访问，**任意位置插入/删除** 快，但占用额外空间。 |
| **`forward_list`**   | 单向链表，支持顺序访问，插入/删除快，占用空间小。 |
| **`array`**          | 固定大小数组，支持 **快速随机访问**，大小不可变。 |
| **`string`**         | 专用于保存字符序列，类似`vector`，但操作功能更丰富。 |

- **`forward_list`** 和 **`array`** 是 C++11 新增的容器。
- **选择容器原则：**
  1. 优先选择 `vector`（除非有特殊需求）。
  2. 需要双端操作选择 `deque`，需要中间插入/删除选择 `list` 或 `forward_list`。
  3. 如果容器大小固定且不会改变，用 `array`。

---

## **2. 容器库概览**

### **2.1 头文件与模板**
- 每种容器类型定义在对应头文件中，例如：
  - `#include <vector>` 定义 `vector` 类型。
  - `#include <list>` 定义 `list` 类型。
- 容器均为模板类型，例如：
  ```c++
  vector<int> ivec;  // 存储 int 类型的 vector
  list<string> slist;  // 存储 string 类型的 list
  ```

### **2.2 迭代器（Iterators）**
- **基本概念：** 
  - 迭代器是对象，提供一种访问容器元素的方式。
  - 大多数容器支持 **前向迭代器** 和 **反向迭代器**。
  - 迭代器范围：左闭右开 `[begin, end)`，`end` 不是最后一个元素，而是尾后位置。
- **迭代器类型：**
  | 迭代器       | 含义                    |
  |--------------|-------------------------|
  | `begin`      | 返回首元素的迭代器。    |
  | `end`        | 返回尾后迭代器。        |
  | `cbegin`     | 返回`const`迭代器（C++11）。 |
  | `rbegin`     | 返回反向首迭代器。      |
  | `rend`       | 返回反向尾后迭代器。    |

### **2.3 容器类型成员**
- 容器通过类型别名定义元素的相关类型：
  | 类型别名           | 含义                        |
  |--------------------|-----------------------------|
  | `value_type`       | 容器中元素的类型。          |
  | `reference`        | 元素的引用类型。            |
  | `const_reference`  | 元素的常量引用类型。        |
  | `iterator`         | 元素的迭代器类型。          |
  | `const_iterator`   | 常量迭代器类型。            |

### **2.4 容器定义与初始化**
- **直接初始化：**
  ```c++
  vector<int> vec = {1, 2, 3, 4};  // 列表初始化（C++11）
  list<string> slist = {"Austen", "Shakespeare"};  
  ```
- **从其他容器拷贝：**
  - 容器类型和元素类型必须完全一致：
    ```c++
    list<string> slist(authors);  // 从 authors 初始化
    vector<string> svec(authors);  // 错误：容器类型不同
    ```
  - 使用迭代器范围初始化：
    ```c++
    vector<int> ivec(lst.begin(), lst.end());  // 支持从不同容器初始化
    ```

- **初始化固定大小的`array`：**
  ```c++
  array<int, 5> arr = {1, 2, 3, 4, 5};  // 必须指定大小和类型
  ```

### **2.5 赋值与`swap`**
- 容器支持赋值操作，但容器类型必须相同：
  ```c++
  list<string> names;
  vector<const char*> oldstyle;
  names.assign(oldstyle.cbegin(), oldstyle.cend());  // 类型兼容
  ```
- **`swap`操作：**
  - 交换两个相同类型容器的内容。
  - 对 `vector` 等容器，`swap` 不影响迭代器指向的元素值，但会改变元素所属的容器。

---

## **3. 顺序容器的操作**

### **3.1 插入元素**
- **常用函数：**
  | 操作                  | 含义                                      |
  |-----------------------|-------------------------------------------|
  | `push_back`           | 在容器尾部添加元素。                     |
  | `push_front`          | 在容器头部插入元素（`vector` 不支持）。  |
  | `insert`              | 在指定位置前插入元素（返回指向新元素的迭代器）。 |
  | `emplace_back`        | 在尾部直接构造元素。                     |
  | `emplace_front`       | 在头部直接构造元素（`vector` 不支持）。 |
  | `emplace`             | 在指定位置直接构造元素。                 |

- **示例：**
  ```c++
  vector<string> svec;
  svec.push_back("Hello");  // 在尾部添加 "Hello"
  svec.insert(svec.begin(), "World");  // 在开头插入 "World"
  ```

### **3.2 删除元素**
- **常用函数：**
  | 操作          | 含义                                   |
  |---------------|----------------------------------------|
  | `pop_back`    | 删除尾元素。                          |
  | `pop_front`   | 删除头元素（`vector` 不支持）。       |
  | `erase`       | 删除指定位置的元素，或范围内的元素。   |
  | `clear`       | 删除容器中的所有元素。                |

- **示例：**
  ```c++
  list<int> ilist = {1, 2, 3, 4};
  ilist.pop_front();  // 删除头部元素
  ilist.erase(ilist.begin());  // 删除第一个元素
  ```

### **3.3 访问元素**
- **常用函数：**
  | 操作          | 含义                                   |
  |---------------|----------------------------------------|
  | `front`       | 返回首元素的引用。                     |
  | `back`        | 返回尾元素的引用（`forward_list` 不支持）。 |
  | `at`          | 安全访问指定位置的元素，越界时抛出异常。|
  | `operator[]`  | 使用下标访问指定位置元素（`vector`、`array` 支持）。 |

- **示例：**
  ```c++
  vector<int> vec = {1, 2, 3, 4};
  cout << vec.front();  // 输出 1
  cout << vec[2];       // 输出 3
  ```

### **3.4 改变大小**
- **`resize`：**
  - 增加或减少容器大小：
    ```c++
    vector<int> vec = {1, 2, 3};
    vec.resize(5, 0);  // 增加至 5 个元素，新增元素值为 0
    ```

---

## **4. `vector` 的增长**

- **`vector` 的容量（capacity）：**
  - **`capacity`：** 返回当前分配的内存能容纳的元素数量。
  - **`reserve`：** 预留空间，避免频繁重新分配。
  - **`shrink_to_fit`（C++11）：** 释放未使用的多余内存（不保证一定生效）。
  - 示例：
    ```c++
    vector<int> vec;
    vec.reserve(100);  // 提前分配 100 个空间
    ```

---

## **5. `string` 额外操作**

### **5.1 搜索与替换**
- **搜索操作：**
  - 返回目标位置索引（`size_type`），若搜索失败返回 `string::npos`。
  - 示例：
    ```c++
    string s = "hello world";
    auto pos = s.find("world");  // 返回位置 6
    ```

- **替换与插入：**
  ```c++
  string s = "hello";
  s.insert(5, " world");  // 插入 " world"，结果为 "hello world"
  s.replace(6, 5, "C++");  // 替换 "world" 为 "C++"
  ```

---

## **6. 容器适配器**

### **6.1 适配器概述**
- **适配器：** 将已有容器封装为特定用途的结构。
  - **`stack`：** 栈（后进先出）。
  - **`queue`：** 队列（先进先出）。
  - **`priority_queue`：** 优先队列。

- **默认容器：**
  - `stack` 和 `queue` 默认基于 `deque`。
  - `priority_queue` 默认基于 `vector`。

### **6.2 示例**
```c++
stack<int> stk;  // 默认使用 deque
stk.push(10);    // 入栈
stk.pop();       // 出栈
cout << stk.top();  // 获取栈顶元素
```

---

## **总结**
- 顺序容器支持灵活的插入、删除和访问操作。
- `vector` 是最常用的容器，适用于多数场景。
- 理解容器的迭代器失效规则、容量管理、适配器等特性，有助于编写高效代码。