# 第12章 动态内存 - 总结笔记

---

## **1. 动态内存基础**

### **1.1 动态内存分配**
- **堆内存**：程序运行时动态分配的内存由堆（heap）管理。
- **`new` 和 `delete`**：
  - **`new`**：在堆中分配对象并返回指针，可选择性初始化。
  - **`delete`**：释放由 `new` 分配的内存。
```cpp
int* pi = new int(1024);   // 动态分配一个值为 1024 的 int 对象
delete pi;                 // 释放动态分配的内存
```

### **1.2 动态内存的常见问题**
- **空悬指针（dangling pointer）**：`delete` 后未将指针置为 `nullptr`。
- **重复释放**：释放同一块内存多次，行为未定义。
- **内存泄漏**：未释放动态分配的内存，导致内存耗尽。

---

## **2. 智能指针（Smart Pointers）**

智能指针提供动态内存的自动管理功能，避免手动调用 `delete` 引发的问题。

### **2.1 智能指针类型**
1. **`shared_ptr`**：支持多个智能指针共享同一块内存，采用引用计数管理对象。
2. **`unique_ptr`**：独占所有权，同一时刻只能有一个指针指向对象。
3. **`weak_ptr`**：弱引用，辅助 `shared_ptr`，不增加引用计数。

### **2.2 智能指针头文件**
- **头文件**：`memory`

### **2.3 `shared_ptr`**

- **特性**：通过引用计数管理动态内存，当引用计数为 `0` 时释放内存。
- **操作：**
  | 操作                | 含义                                             |
  |---------------------|--------------------------------------------------|
  | `shared_ptr<T> sp`  | 创建一个空智能指针                                |
  | `make_shared<T>(...)` | 创建一个 `shared_ptr` 并动态分配和初始化对象    |
  | `sp.use_count()`    | 返回引用计数                                      |
  | `sp.unique()`       | 若 `use_count() == 1` 返回 `true`                 |
  | `sp.get()`          | 返回普通指针，指向共享的对象                      |
  | `sp.reset()`        | 重置智能指针，释放当前对象并可以指向新对象        |

```cpp
auto sp1 = make_shared<int>(10);    // sp1 指向一个值为 10 的 int
auto sp2 = sp1;                    // sp1 和 sp2 共享同一个对象
sp1.reset();                       // sp1 不再共享对象，但 sp2 仍然指向对象
cout << sp2.use_count();           // 输出 1
```

- **注意事项**：
  - 不要混用普通指针和智能指针管理相同的内存。
  - 不要使用 `get` 返回的裸指针去 `delete` 内存。

---

### **2.4 `unique_ptr`**

- **特性**：独占内存所有权，不支持拷贝或赋值（可通过移动语义转移所有权）。
- **常用操作：**
  | 操作                     | 含义                                             |
  |--------------------------|--------------------------------------------------|
  | `make_unique<T>(...)`    | 创建并初始化一个 `unique_ptr`（C++14）           |
  | `up.release()`           | 释放所有权并返回裸指针                          |
  | `up.reset(ptr)`          | 重置为指向新对象（释放原对象）                   |

```cpp
unique_ptr<int> up1 = make_unique<int>(42); // up1 独占一个值为 42 的对象
unique_ptr<int> up2 = move(up1);            // 转移所有权给 up2，up1 为空
int* raw_ptr = up2.release();               // 释放所有权，up2 为空
delete raw_ptr;                             // 手动释放内存
```

---

### **2.5 `weak_ptr`**

- **特性**：不参与对象的引用计数管理。
- **作用**：防止 `shared_ptr` 的循环引用。
- **操作：**
  | 操作             | 含义                                                         |
  |------------------|--------------------------------------------------------------|
  | `weak_ptr<T> wp` | 从 `shared_ptr` 初始化 `weak_ptr`                             |
  | `wp.lock()`      | 返回一个 `shared_ptr` 指向对象，若对象已释放，则返回空指针     |
  | `wp.expired()`   | 判断 `weak_ptr` 所指向的对象是否已被释放                      |

```cpp
auto sp = make_shared<int>(42);
weak_ptr<int> wp(sp);  // wp 指向 sp 管理的对象
if (auto np = wp.lock()) {  // 获取 shared_ptr
    cout << *np;           // 输出对象值
}
```

---

## **3. 使用动态内存的场景**

1. **不确定对象数量**：如读取输入的数据存储到容器中。
2. **共享数据**：在多个对象之间共享数据时使用 `shared_ptr`。
3. **动态对象生存期**：需要控制对象的生存周期时。

---

## **4. 动态数组**

### **4.1 `new` 和数组**
- **分配动态数组：**
```cpp
int* arr = new int[10];          // 动态分配数组，未初始化
int* arr2 = new int[10]();       // 动态分配数组，值初始化为 0
int* arr3 = new int[10]{1, 2};   // 前两个元素初始化为 1 和 2，其他为 0
```

- **释放动态数组：**
  - 使用 `delete[]` 释放内存。
```cpp
delete[] arr;
```

### **4.2 动态数组与智能指针**
- **使用 `unique_ptr` 管理动态数组：**
```cpp
unique_ptr<int[]> up(new int[10]);  // 使用 unique_ptr 管理动态数组
up[0] = 42;                         // 使用下标访问元素
```

- **`shared_ptr` 管理动态数组（需提供自定义删除器）：**
```cpp
shared_ptr<int> sp(new int[10], [](int* p) { delete[] p; });
```

---

## **5. `allocator`类**

### **5.1 作用**
- 将内存分配和对象构造分离，提供更灵活的动态内存管理。

### **5.2 常用操作**
| 操作                    | 含义                                                |
|-------------------------|---------------------------------------------------|
| `alloc.allocate(n)`     | 分配未初始化的内存，可以保存 `n` 个对象             |
| `alloc.construct(p, ...)` | 在指针 `p` 指向的内存中构造对象                   |
| `alloc.destroy(p)`      | 调用指针 `p` 指向对象的析构函数                    |
| `alloc.deallocate(p, n)`| 释放由 `allocate` 分配的内存                       |

### **5.3 示例**
```cpp
allocator<string> alloc;
auto const p = alloc.allocate(10);        // 分配 10 个未初始化的 string
auto q = p; 
alloc.construct(q++, "hello");            // 在 p[0] 位置构造 string
alloc.construct(q++, "world");            // 在 p[1] 位置构造 string

while (q != p) {
    alloc.destroy(--q);                  // 析构构造的 string
}
alloc.deallocate(p, 10);                 // 释放分配的内存
```

---

## **6. 智能指针与异常安全**

- 智能指针能确保动态分配的对象在异常发生时仍被正确释放。
```cpp
void f() {
    shared_ptr<int> sp(new int(42));
    // 如果发生异常，sp 会自动释放所指向的对象
}
```

---

## **7. 小结**

1. **智能指针**是动态内存管理的最佳实践，优先使用 `shared_ptr` 和 `unique_ptr`。
2. **避免混用**智能指针和裸指针。
3. 使用 **`allocator`** 提供更高效的动态内存分配和构造操作。
4. **动态数组**需使用智能指针或手动释放，推荐用容器（如 `vector`）代替裸数组。